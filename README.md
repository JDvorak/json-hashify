# JSONHash

[![npm package](https://nodei.co/npm/jsonhash.png?downloads=true&stars=true)](https://nodei.co/npm/jsonhash/)

JSON Structural Hashing.

Got JSON? Need to know if it's *structurally* and faintly semantically similar to other JSON? Not just `===` identical, but close in shape and content? `JSONHash` is your tool.

This utility takes any JSON object/array, analyzes its structure and content (paths, values, subtrees), generates k-shingles from these features, and then applies Grouped One Permutation Hashing (GOPH) to produce a compact signature ("sketch").

Compare sketches to estimate Jaccard similarity. Fast and effective for detecting structural likeness, perfect for use in an Approximate Nearest Neighbor graph for ASTs, Code Similarity, or More.

## Usage

Simple:

```javascript
import { JSONHash, jsonHash, compareJsonHashes, estimateJaccardSimilarity } from 'jsonhash'; // or require('jsonhash')

// Your JSONs
const json1 = { a: 1, b: { c: 2, d: [3, 4] }, e: "hello" };
const json2 = { a: 1, b: { c: 99, d: [3, 4] }, e: "world" }; // similar structure, different values
const json3 = { x: true, y: false, z: null }; // totally different

// Make a hasher instance (or don't, use the utility fns)
const hasher = new JSONHash({
  shingleSize: 5,         // Default: 5. Size of k-shingles for path:value strings.
  subtreeDepth: 2,        // Default: 2. How deep to look into subtrees.
  frequencyThreshold: 1,  // Default: 1. Min times a shingle must appear.
  numHashFunctions: 128,  // Default: 128. Total hashes in the sketch.
  numGroups: 4,           // Default: 4. Groups for GOPH. numHashFunctions must be divisible by this.
  preserveArrayOrder: true, // Default: true. `arr[0]` vs `arr[1]`. If false, array elements are like a bag.
  ignoreKeys: ['position'], // Default: []. Keys to completely ignore.
  enableNodeStringCache: true, // Default: false. Cache shingle sets for node strings? Speeds up repeats.
  nodeStringCacheSize: 5000  // Default: 1000. Max items in node string cache if enabled.
});

const sketch1 = hasher.generateSketch(json1);
const sketch2 = hasher.generateSketch(json2);
const sketch3 = hasher.generateSketch(json3);

// Or use the quick util fn
const sketch1_alt = jsonHash(json1, { numHashFunctions: 128 });


console.log('Sketch 1:', sketch1);

// How similar are they? (0.0 to 1.0)
const similarity12 = hasher.compareSketches(sketch1, sketch2);
console.log('Similarity json1 vs json2:', similarity12); // Should be kinda high

const similarity13 = compareJsonHashes(sketch1, sketch3); // Util fn for comparison too
console.log('Similarity json1 vs json3:', similarity13); // Should be pretty low

// You can also get the raw shingle set before GOPH if you're curious
const shingleSet1 = hasher.generateShingleSet(json1);
// console.log('Shingles for json1:', shingleSet1);

// If you're using the cache and processing lots of similar stuff, clear it sometimes:
hasher.clearNodeStringCache();

// The estimateJaccardSimilarity is also exported if you have sketches from elsewhere
// and know they were made with compatible GOPH params.
// const directSim = estimateJaccardSimilarity(sketch1, sketch2);
```

## API

### `new JSONHash(options?)`

Creates a new `JSONHash` instance.

*   `options` (Object, optional):
    *   `shingleSize` (Number, default: `5`): Size of k-shingles.
    *   `subtreeDepth` (Number, default: `2`): Depth for subtree extraction.
    *   `frequencyThreshold` (Number, default: `1`): Minimum shingle frequency.
    *   `numHashFunctions` (Number, default: `128`): Total hashes in the sketch (must be divisible by `numGroups`).
    *   `numGroups` (Number, default: `4`): Number of groups for GOPH.
    *   `preserveArrayOrder` (Boolean, default: `true`): Distinguish array elements by index.
    *   `ignoreKeys` (Array<String>, default: `[]`): Keys to ignore.
    *   `enableNodeStringCache` (Boolean, default: `false`): Enable an LRU cache for node string shingle sets. Useful if processing many identical sub-structures or the same JSON repeatedly.
    *   `nodeStringCacheSize` (Number, default: `1000`): Max size of the node string cache if enabled.

### `hasher.generateSketch(json)`

Generates a GOPH sketch (an array of numbers) for the input `json`.

### `hasher.generateShingleSet(json)`

Generates the set of unique shingle hashes (integers) for the input `json` after frequency thresholding but *before* GOPH.

### `hasher.compareSketches(sketch1, sketch2)`

Estimates Jaccard similarity (0 to 1) between two sketches generated by a `JSONHash` instance with compatible settings.

### `hasher.clearNodeStringCache()`

Clears the internal node string shingle cache if it was enabled.

### `jsonHash(json, options?)`

Utility function. Creates a temporary `JSONHash` instance with `options` and returns `hasher.generateSketch(json)`.

### `compareJsonHashes(sketch1, sketch2, options?)`

Utility function. Creates a temporary `JSONHash` instance (options usually not needed here unless GOPH params differ from defaults, which is unlikely for comparison) and returns `hasher.compareSketches(sketch1, sketch2)`.

### `estimateJaccardSimilarity(sketch1, sketch2)`

Directly estimates Jaccard similarity from two sketches. Assumes sketches are compatible (same number of hash functions and groups).

## Performance

Benchmarks run with `node bench/random-json.js`. HPS = Hashes Per Second (higher is better).
"Stateful" uses `enableNodeStringCache` for repeated processing of the same JSON.
"Stateless" implies a new hasher instance or cache disabled.

| Benchmark Configuration         | Mode      | HPS        | Duration (approx) |
|---------------------------------|-----------|------------|-------------------|
| JSON (Depth 2, Max Children 3)  | Stateless | 25331.72   | ~395 ms           |
| JSON (Depth 2, Max Children 3)  | Stateful  | 38452.93   | ~260 ms           |
| JSON (Depth 3, Max Children 5)  | Stateless | 3556.71    | ~2.81 s           |
| JSON (Depth 3, Max Children 5)  | Stateful  | 5447.61    | ~1.84 s           |
| JSON (Depth 4, Max Children 5)  | Stateless | 1205.27    | ~8.30 s           |
| JSON (Depth 4, Max Children 5)  | Stateful  | 1656.03    | ~6.04 s           |
| JSON (Depth 3, Max Children 8)  | Stateless | 1273.21    | ~7.85 s           |
| JSON (Depth 3, Max Children 8)  | Stateful  | 1830.51    | ~5.46 s           |
| JSON (Depth 5, Max Children 3)  | Stateless | 2313.16    | ~4.32 s           |
| JSON (Depth 5, Max Children 3)  | Stateful  | 1576.99    | ~6.34 s           |



*(Note: The Depth 5, Max Children 3 Stateful run is slower. This can happen! Cache management has overhead. If your JSON is super unique each time, or very complex in specific ways, stateless might sometimes edge out cached for single runs. The cache shines with repetition of substructures or whole objects.)*

### Recent Optimizations & Important Considerations

This library has undergone several profiling-guided optimizations to improve the speed of sketch generation. Key changes include:

*   **Shingle Generation Efficiency**: Internal logic for shingle generation (`_buildShingleMultiset`, `_updateShingleFrequenciesForNode`) was refactored to reduce the creation of intermediate `Set` objects and to directly update a `Map` tracking shingle frequencies. This minimizes overhead from set operations.
*   **Input JSON Pre-processing Hint**: For performance, `JSONHash` no longer internally normalizes strings by trimming whitespace or collapsing multiple spaces (e.g., `nodeString.replace(/\s+/g, ' ').trim()`). If your use case requires that variations in whitespace within JSON string values (such as `"hello  world"` vs. `"hello world"`) should produce the same hash, you should pre-process and normalize your JSON objects before passing them to `JSONHash`.
*   **Optimized Hashing for GOPH**: The underlying `goph` library, used for the Grouped One Permutation Hashing stage, was updated. Specifically, when `JSONHash` provides numeric shingle hashes to `goph`, these numbers are now hashed directly as 32-bit integers. Previously, these numbers were converted to strings before being hashed by `goph`'s `murmurhash3_32_gc`.


## Why?

There's a lot of cases where you want a vector to roughly compare two objects. For instance, in deduplication, or in the clustering of structural features. If you wanted to find code duplication, then you could calculate the AST of the codebase, then recursively JSONHash the resulting AST and quickly find duplication much faster than any deterministic approach. Similarly, if you were to encode the neighborhood tree of a node in a graph, you could find similar structures much more rapidly than if you used any graph analysis algorithms. Due to the nature of the shingling this is content sensitive as well. Structures with keys in common will cluster closer than identical structures without keys in common. This makes it ideal for a lot of common "Similarity" use cases.


## Install

```bash
npm install jsonhash
```


## License

MIT. 2023